# Verify setting of working directory, volumes and environment variables for module-aware projects

# Establish the image we are using.
# Note that we need the same libc that the host is using.
# On Linux, we assume glibc. We use a pinned Debian Testing,
# because stable Debian often has a glibc that's too old.
[!windows] env IMAGE=debian:bookworm-20211220-slim
[windows] skip 'TODO: support windows-native images in --volume flags'
[windows] env IMAGE=mcr.microsoft.com/windows/nanoserver:1809

exec go test -exec='dockexec '$IMAGE' -v '$HOST_GOROOT':/goroot ' -v ./cmd/blah
! stderr .+

# working directory
[!windows] stdout '^\Qworking directory: /start/cmd/blah\E$'
[windows]  stdout '^\Q\E$'

[!windows] stdout '^\Qmain module root: /start/go.mod\E$'
[windows]  stdout '^\Q\E$'

# gomodcache
[!windows] stdout '^\Qgomodcache: /gomodcache\E$'
[windows]  stdout '^\Q\E$'

# gocache
[!windows] stdout '^\Qgocache: /gocache\E$'
[windows]  stdout '^\Q\E$'

-- go.mod --
module mod.com

-- cmd/blah/main.go --
package main

-- cmd/blah/main_test.go --
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"testing"
)

func TestOutput(t *testing.T) {
	// Output working directory
	wd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get working directory: %v", err)
	}
	fmt.Printf("working directory: %v\n", wd)

	// Verify that we can run go
	var env struct {
		GOMODCACHE string
		GOCACHE    string
		GOMOD      string
	}
	cmd := exec.Command("/goroot/bin/go", "env", "-json")
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("failed to run %v: %v\n%s", strings.Join(cmd.Args, " "), err, out)
	}
	if err := json.Unmarshal(out, &env); err != nil {
		t.Fatalf("failed to unmarshal %v output: %v", strings.Join(cmd.Args, " "), err)
	}
	fmt.Printf("main module root: %v\n", env.GOMOD)
	fmt.Printf("gomodcache: %v\n", env.GOMODCACHE)
	fmt.Printf("gocache: %v\n", env.GOCACHE)
}
